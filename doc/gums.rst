===========================================
Gene trees Under Migration Simulator (GUMS)
===========================================

GUMS simulates a gene tree under a migration and multispecies coalescent
model. GUMS input is a species tree -- a specification of species divergence
times and effective population sizes -- and migration parameters. The species
tree(s) are either specied in the command line or read from a NEXUS file.
Migration parameters can be specified as part of the tree or generated
stochastically.

For the species tree we use the augmented `NEWICK
<http://en.wikipedia.org/wiki/Newick_format/>`_ format. Population sizes and
migration parameters can be specified in nodes meta data; the format is similar
to the one used in BEAST, which was inspired by `NHX
<http://phylosoft.org/NHX//>`_. The effective population size(s) have the same
format as generated by \*BEAST (:ref:`MetapopSize`), and migration rates are
either explicit or generated stochastically.

You can use biopy to generate species trees by drawing a tree from Birth/Death
process and using simple scenarios for setting population sizes
(:ref:`sameSpTrees`).

Most options are straightforward and their usage should be obvious from the help
text (**gums -h**) and the examples below. However, setting the migration rates
in a species tree context requires more care. In our model, rates may change and
are given as a function over time, just like population sizes. There are two
emigration rates associated with each divergence of the ancestral species A into
:math:`A_1` and :math:`A_2` - one for :math:`A_1 \rightarrow A_2` and one for
:math:`A_2 \rightarrow A_1`. In our model, those rates are in effect even after
:math:`A_1` or :math:`A_2` split into subspecies too. For that reason, the
domain of each rate function is from 0 (time of the tips), to the time of
divergence (internal node height). This is diffrent from population size
functions whose domain is just the branch, where time zero (0) is the internal
node height. In both cases time flows backwards, increasing with the distance to
the tips.

The easiest way to set the rates is to use the ``-s`` (``--scenario``)
option. Currently there are three scenarios: constant, balanced and gradual. In
the constant scenario the rates are constant (i.e. have a fixed value from the
time of divergence to the tips), and are drawn independently from a user defined
distribution. The balanced scenario is similar, but the rates :math:`A_1
\rightarrow A_2` and :math:`A_2 \rightarrow A_1` are always equal. The gradual
scenario uses two parameters, M and S. The rate function is linear, starting at
M at the time of divergence and drops to 0 at S. Both M and S are drawn from a
user provided distributions. Also, migration into :math:`A_1` and :math:`A_2`
from other species stops when migration between :math:`A_1` and :math:`A_2`
ceases. The usage section provides some examples, and :ref:`randDists` lists all
available random distributions.

Alternatively, rates can be set explicitly inside the tree. A rate function is
specified using the ``imrv`` and ``imrt`` meta attributes, providing the values
at time points for a piecewise linear function, exactly in same way ``dmv`` and
``dmt`` specify population sizes (:ref:`MetapopSize`). The tricky part is that
the data in the internal node specifies the rate function for the parent node:
this seems the easiest way to work around the fact that each node requires rates
for the left and right sub-trees, but the order of sub-trees in the NEWICK
format is arbitrary. If you are still confused, I suggest looking at the
examples below and at species trees generated under the gradual scenario with
the ``--log`` option).


Usage:
------

::

 # Specify tree and migration rates in the command line. The (constant)
 # population size is given by dmv: 2 for 'a', 1 for 'b' and 1 for the
 # ancestor. Migration rate (M) is constant as well, given by 'imrv' (.4 for a
 # and .6 for b).
 # By default gums prints one gene tree to standard output. The total number of
 # migration events is reported in 'nim'.


| $ ``gums "(a[&imrv=0.4,dmv=2]:1,b[&imrv=0.6,dmv=1]:1)[&dmv=1]"``
| ((b_tip1:0.645476769587,a_tip0:0.645476769587):0.95831702107,(b_tip0:1.34933738445,a_tip1:1.34933738445):0.254456406207)[&nim 2]

::

 # Generate two trees (-n 2)

| $ ``gums -n 2 "(a[&imrv=0.4,dmv=2]:1,b[&imrv=0.6,dmv=1]:1)[&dmv=1]"``
| ((a_tip1:0.479886426509,b_tip1:0.479886426509):2.40342028268,(b_tip0:0.393951094328,a_tip0:0.393951094328):2.48935561487)[&nim 2]
| (((b_tip0:0.0945651926813,b_tip1:0.0945651926813):0.918685788982,a_tip0:1.01325098166):0.613837824988,a_tip1:1.62708880665)[&nim 4]

::

 # Output trees to 'trees.nex' in NEXUS format
  
| $ ``gums -o trees.nex "(a[&imrv=0.4,dmv=2]:1,b[&imrv=0.6,dmv=1]:1)[&dmv=1]"``
| $ ``cat trees.nex``

::

  [Generated by genetree_in_sptree_mig_sim.py, version 0.1.6]
  [/usr/local/bin/gums -o trees.nex (a[&imrv=0.4,dmv=2]:1,b[&imrv=0.6,dmv=1]:1)[&dmv=1]]
  #NEXUS
  begin trees;
  tree tree_0 = [&R] (((b_tip1:0.252172456527,a_tip1:0.252172456527):0.113487587236,a_tip0:0.365660043763):2.12869603649,b_tip0:2.49435608026)[&nim 4] ;
  end;

::

  # Explicitly specify lineages (the labels attribute)
  
| $ ``gums "(a[&imrv=0.4,dmv=2,labels=a1 a2 a3]:1,b[&imrv=0.6,dmv=1,labels=b1 b2]:1)[&dmv=1]"``
| ``(((a3:0.378861178516,a1:0.378861178516):0.0121979519199,b1:0.391059130436):1.97747893368,(b2:0.606737574127,a2:0.606737574127):1.76180048999)[&nim 4]``

::

  # Simulate with 3 lineages per species.

| $ ``gums -t 3 "(a[&imrv=0.4,dmv=2]:1,b[&imrv=0.6,dmv=1]:1)[&dmv=1]"``
| (((a_tip0:0.260681648931,a_tip2:0.260681648931):1.08306884015,(b_tip0:0.671588798321,(b_tip1:0.291571820222,b_tip2:0.291571820222):0.380016978099):0.672161690764):0.285979539237,a_tip1:1.62973002832)[&nim 6]

::

  # Use a constant M for all branches
  
| $ ``gums --scenario constant .4 "(a[&dmv=2]:1,b[&dmv=1]:1)[&dmv=1]"``
| ((a_tip1:1.37587574756,(b_tip0:0.114472140834,b_tip1:0.114472140834):1.26140360672):0.670541106981,a_tip0:2.04641685454)[&nim 1]

::

  # M for every branch is assigned independently, sampled from a uniform
  # distribution on [0.3,0.5]
  
| $ ``gums --scenario constant u,.3,.5 "(a[&dmv=2]:1,b[&dmv=1]:1)[&dmv=1]"``
| (((b_tip0:0.745703759372,a_tip0:0.745703759372):0.346829780156,b_tip1:1.09253353953):4.12033590372,a_tip1:5.21286944325)[&nim 2]

::

  # M for every divergence is assigned independently, migration rate of X -> Y is equal to Y ->
  # X. The -l (--log) option logs the generated species trees

| $ ``gums -l sptrees.nex --scenario balanced u,.3,.5 "(a[&dmv=2]:1,b[&dmv=1]:1)[&dmv=1]"``
| ((a_tip0:0.544745625794,a_tip1:0.544745625794):1.35928052487,(b_tip1:0.258689734603,b_tip0:0.258689734603):1.64533641606)[&nim 1]
| ``$ cat sptrees.nex``

::

  #NEXUS
  begin trees;
  tree tree_0 = [&R] (a[&imrv=0.468464300359,dmv=2.000000]:1.0,b[&imrv=0.468464300359,dmv=1.000000]:1.0)[&dmv=1.000000] ;
  end;

::

  # Non-constant Population sizes. 'a' population size varies linearly between 2
  # (at time 0, tip of branch) to 1/2 at the end of the branch (1 time unit ago)
  
| $ ``gums -l sptrees.nex --scenario constant .4 "(a[&dmv={2,0.5}]:1,b[&dmv=1]:1)[&dmv=1]"``
| ((b_tip1:0.510950861838,(a_tip1:0.0824282355471,b_tip0:0.0824282355471):0.428522626291):1.17963320687,a_tip0:1.69058406871)[&nim 1]

::

  Gradual scenario.
  
| $ ``gums --scenario gradual u,.3,.5 l,.3,.2 --log trees.nex "((a[&dmv=2]:1,b[&dmv=1]:1)[&dmv=1]:1,c[&dmv=1]:3)[&dmv=1]"``
| ((c_tip0:0.530848069964,c_tip1:0.530848069964):4.58955020846,((b_tip1:0.0991069047618,b_tip0:0.0991069047618):1.97184729447,(a_tip0:0.391830914289,a_tip1:0.391830914289):1.67912328494):3.04944407919)[&nim 1]

This is how the generated rates looks like inside the tree

::

  ((a[&imrt={0.600357,1.000000},imrv={0.000000,0.000000,0.354169},dmv=2.0]:1.0,
    b[&imrt={0.600357,1.000000},imrv={0.000000,0.000000,0.354169},dmv=1.0]:1.0)
                 [&imrt={2.828391,3.000000},imrv={0.000000,0.000000,0.316630},dmv=1.0]:1.0,
   c[&imrt={2.828391,3.000000},imrv={0.000000,0.000000,0.316630},dmv=1.0]:3.0)[&dmv=1.0]


The rate between a and b starts at 0.354169 and goes to zero over 0.399643
(1-0.600357) time units. In a similar way, rate between c and the ancestor of a,b
goes from 0.316630 to zero in 0.171609.

::

  Generating the species tree on the fly.

Use :ref:`sameSpTrees` to obtain a species tree. The tree is a pure birth (Yule)
tree with a birth rate of 0.5 (``-b .5``). This means that for the waiting time
for a lineage to split is distributed exponentially with a mean of 2
(:math:`^1/_{0.5}`). Note that this does not mean the average length of the
branch is 2. In fact it is 1, half of the waiting time. The population sizes are
set randomly to be around half of the expected length, 40% to 60% percent to be
exact (``-p U,0.4,0.6 5``). 

  
| $ ``gums -n 2 -t 3 -s balanced U,0.1,0.3 --log log1.nex $(sample_species_tree -n 1 -b .5 -p U,0.4,0.6 5)``
| (((s0_tip1:0.633753370771,(s0_tip0:0.20140491595,s0_tip2:0.20140491595):0.432348454821):1.02981316427,(s1_tip2:0.0231071519315,s1_tip1:0.0231071519315):1.64045938311):3.30364142647,(((s3_tip0:0.0617867053147,s3_tip1:0.0617867053147):1.09555801093,(((s2_tip2:0.0228829294601,s2_tip1:0.0228829294601):0.00804435880388,s2_tip0:0.030927288264):0.612433605667,(s4_tip0:0.185733213651,(s4_tip1:0.154559848603,s4_tip2:0.154559848603):0.0311733650483):0.457627680279):0.513983822315):1.01800552519,(s1_tip0:0.397138102826,s3_tip2:0.397138102826):1.77821213861):2.79185772007)[&nim=5]
| (((((s2_tip2:0.300176848337,(s1_tip1:0.093590427987,s1_tip2:0.093590427987):0.20658642035):0.55612489683,(s1_tip0:0.318841270065,s4_tip0:0.318841270065):0.537460475103):0.836119414335,(((s2_tip1:0.311003975618,(s0_tip2:0.0815087077626,s0_tip1:0.0815087077626):0.229495267856):0.402856951107,(s3_tip1:0.252809256857,s3_tip0:0.252809256857):0.461051669869):0.375542380001,(s2_tip0:0.783668773989,s3_tip2:0.783668773989):0.305734532737):0.603017852776):0.391695370206,s0_tip0:2.08411652971):0.173437110502,(s4_tip1:0.224873965382,s4_tip2:0.224873965382):2.03267967483)[&nim=7]
