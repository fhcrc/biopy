#! /usr/bin/env python
## This file is part of biopy.
## Copyright (C) 2010 Joseph Heled
## Author: Joseph Heled <jheled@gmail.com>
## See the files gpl.txt and lgpl.txt for copying conditions.
#

from __future__ import division

import optparse, sys, os.path
from time import time

from biopy.genericutils import fileFromName
from biopy.treeutils import toNewick, countNexusTrees, nodeHeights, getCommonAncesstor

from biopy.treesPosterior import minPosteriorDistanceTree
from biopy import INexus
from biopy import beastXMLhelper

parser = optparse.OptionParser(usage =  """ %prog [OPTIONS] posterior-trees.nexus 

  Generate a single summary tree for a set of posterior trees.""")

parser.add_option("-b", "--burnin", dest="burnin",
                  help="Burn-in amount (percent, default %default)", default = "10")

parser.add_option("-e", "--every", dest="every", metavar="E",
                  help="""thin out - take one tree for every E. Especially
                  useful if you run out of memory (default all,
                  i.e. %default)""", default = "1")

parser.add_option("-n", "--ntops", dest="ntops", metavar="N",
                  help="""Use the top N topologies from the posterior (default
                  %default)""", default = "10")

parser.add_option("-l", "--limit", dest="limit", metavar="S",
                  help="""run at most S seconds, trying out topologies in""" + \
                  """ decreasing order of support and in random order for""" + \
                  """ topologies with equal support (default -1, i.e no""" + \
                  """ time limits). Note that timing code has not been""" + \
                  """ tested under M$windows or OSX """, 
                  default = "-1") 

parser.add_option("-t", "--topology", dest="topology",
                  help="""Try only this topology""", default = None)

parser.add_option("", "--score", dest="score",
                  help="Print score as a tree attribute",
                  action="store_true", default = False)

parser.add_option("", "--matching", dest="matching",
                  help="With --topology, use only posterior trees with an """ +
                  """identical topology to the target.""",
                  action="store_true", default = False)

parser.add_option("", "--compatible", dest="compatible", metavar="TREE",
                  help="Insure gene tree is compatible with species TREE.",
                  default = None)

parser.add_option("", "--species-mapping", dest="spmap", metavar="FILE",
                  help=("A file contatining the mapping of gene lineages to" + 
                        " species for the --compatible option (currently " + 
                        "only BEAST(1) XML file supported). Otherwise, a simple" +
                        " scheme of looking for the species name inside the gene" +
                        " name is used."),
                  default = None)

parser.add_option("-p", "--progress", dest="progress",
                  help="Print out progress messages to terminal (standard error)",
                  action="store_true", default = False)

parser.add_option("", "--no-derivative", dest="derivative",
                  help="Do not use analytic derivative in optimization function",
                  action="store_false", default = True)

options, args = parser.parse_args()

nexusTreesFileName = args[0]
try :
  nexFile = fileFromName(nexusTreesFileName)
except Exception,e:
  # report error
  print >> sys.stderr, "Error:", e.message
  sys.exit(1)

progress = options.progress
burnIn = float(options.burnin)
if 0 < burnIn < 1 :
  print >> sys.stderr, ("*** Warning ***: tiny value for burn-in. Burn-in is"
                        " given as a percent, betwee 0 and 100.")
burnIn /= 100.0

every = int(options.every)
ntops = int(options.ntops)
limit = int(options.limit)
useOnlyMatchingTopologies = options.matching

if options.topology is not None :
  try :
    options.topology = INexus.Tree(options.topology)
  except Exception,e:
    print >> sys.stderr, "Error in parsing tree:", e.message
    sys.exit(1)
else :
  if useOnlyMatchingTopologies:
    print >> sys.stderr, """Using --matching without --topology is\
 dubious. procceding anyway..."""

if options.compatible is not None :
  if os.path.isfile(options.compatible) :
    spTree = INexus.INexus(options.compatible).trees[0]
  else :
    try :
      spTree = INexus.Tree(options.compatible)
    except Exception,e:
      print >> sys.stderr, "*** Error: failed to parse tree: ",\
            e.message,"[",options.compatible,"]"
      sys.exit(1)

  if options.spmap is not None :
    bd = {'species':None}
    bsps = beastXMLhelper.readBeastFile(options.spmap, bd)
    speciesMapping = bd['species']['species']

    def getSpeciesOf(name) :
      for x in speciesMapping :
        if name in speciesMapping[x] :
          return x
      return None
    
  else :

    spTerms = spTree.get_terminals()
    spNames = [spTree.node(x).data.taxon for x in spTerms]

    def getSpeciesOf(name) :
      b = [x in name for x in spNames]
      if sum(b) == 1 :
        sid = b.index(True)
        return spNames[sid]
      return None
    
    #print >> sys.stderr, ("*** Error: must specify a mapping" +
    #                      " (--species-mapping) with --compatible")
    #sys.exit(1)

    
  def _setSPS(tr, nid) :
    """ Store the set of species spanned by the subtree in each node.

    At the end, each node of tree 'tr' contains the data.species memeber, a set
    species names as strings.
    """
    n = tr.node(nid)

    if not len(n.succ) :
      # leaf
      s = getSpeciesOf(n.data.taxon)
      assert s is not None, n.data.taxon
      allsp = frozenset([s])
    else :
      # internal node
      l = [_setSPS(tr, x) for x in n.succ]
      allsp = reduce(lambda x,y : x.union(y), l)

    n.data.species = allsp
    return n.data.species

  def getSPlimits(gtr, spt = spTree) :
    """ Establish a mapping between each internal node of the gene tree 'gtr' and
    its minimum height according to species tree spt.
    """

    nh = nodeHeights(gtr, allTipsZero = False)
    snh = nodeHeights(spt, allTipsZero = False)

    _setSPS(gtr, gtr.root)
    for i in gtr.all_ids() :
      n = gtr.node(i)
      if len(n.succ) :
        if len(n.data.species) > 1 :
          stx = [spt.search_taxon(x) for x in n.data.species]        
          k = getCommonAncesstor(spt, stx)
          b = snh[k]
        else :
          b = 0
        nh[i] = b 
    return nh
    
if progress:
  print >> sys.stderr, "counting trees ...,",
nTrees = countNexusTrees(nexusTreesFileName)

# establish trees

nexusReader = INexus.INexus()

nBurninTrees = int(burnIn*nTrees)

if progress:
  print >> sys.stderr, "reading %d trees ...," % (nTrees - nBurninTrees),

try :
  trees = list(nexusReader.read(nexFile, slice(nBurninTrees, -1, every)))
except Exception,e:
  print >> sys.stderr, "**Problem reading trees file:", e.message
  sys.exit(1)

if len(trees) == 0 :
  print >> sys.stderr, "**Error: No trees"
  sys.exit(1)

if 1 :
  # Save some memory when trees contains attributes, small speed penalty
  for tree in trees :
    for nid in tree.all_ids() :
      data = tree.node(nid).data
      if hasattr(data, "attributes") :
        del data.attributes
   
if 1:
  if progress:
    print >> sys.stderr, "collect topologies and sort ...,",
  topology = dict()
  for tree in trees :
    k = toNewick(tree, None, topologyOnly=True)
    if k not in topology :
      topology[k] = [tree,]
    else :
      topology[k].append(tree)

  allt = topology.items()
  # Sort by amount of support
  allt.sort(reverse=1, key = lambda l : len(l[1]))

if ntops > len(allt) :
  ntops = len(allt)
  
if options.topology is not None :
  candidates = [options.topology]
  limit = -1
elif limit <= 0 :
  if progress:
    pPost = sum([len(x[1]) for x in allt[:ntops]]) / len(trees)
    print >> sys.stderr, """using top %d topologies out of %d, covering %.1f%% of\
 posterior topologies...,""" % \
          (min(ntops, len(allt)), len(allt), 100*pPost),

  k = ntops-1
  lLast = len(allt[k][1])
  while k < len(allt) and lLast == len(allt[k][1]) :
    k += 1
  if k > ntops :
     print >> sys.stderr
     print >> sys.stderr, """*** WARNING ***:  %d additional topologies have the \
same support as the %dth one (%d trees, %.3f%%)""" % (k - ntops, ntops, lLast, lLast/len(trees))
       
  candidates = [x[1][0] for x in allt[:ntops]]
else :
  import random

  candidates = []
  while len(candidates) < len(allt) :
    l = []
    k = len(candidates)
    lFirst = len(allt[k][1])
    while k < len(allt) and lFirst == len(allt[k][1]) :
      l.append(allt[k][1][0])
      k += 1
    random.shuffle(l)
    # print len(candidates), len(l), lFirst
    candidates.extend(l)

  #for x in candidates:
  #  print toNewick(x, None, topologyOnly=1)
  print >> sys.stderr, """trying in order %d topologies (time permitting) ...""" \
        % len(candidates),
  
bestTree, bestScore = None, float('infinity')

if progress:
  print >> sys.stderr, "searching ...,",

nCandidatesTried = 0

if limit > 0 or progress :
  startTime = time()

postTrees = trees

for tree in candidates:
  if useOnlyMatchingTopologies:
    k = toNewick(tree, None, topologyOnly=True)
    if k not in topology :
      # no such trees, skip topology
      print >> sys.stderr, "*** skip %s, no posterior trees" % k
      continue
    postTrees = topology[k]
    print >> sys.stderr, "Using %d posterior trees (out of %d) for %s" \
          % (len(postTrees), len(trees), k) 

  nh = getSPlimits(tree) if options.compatible is not None else None
    
  norm = True
  tr, score = minPosteriorDistanceTree(tree, postTrees, norm = norm,
                                       nodesMinHeight = nh,
                                       withDerivative = options.derivative)
  
  # normalize score
  score = (score / len(postTrees)) ** 0.5

  #print 
  #print score,toNewick(tr)

  if score < bestScore:
    bestScore = score
    bestTree = tr
  nCandidatesTried += 1
  if limit > 0 or progress :
    timenow = time()
    if progress:
      print >> sys.stderr, \
            ("%ds/%d (%g), " % (round(timenow - startTime),
                                nCandidatesTried,bestScore)),
    if timenow - startTime >= limit > 0 :
      print >> sys.stderr, "time limit reached ...,",
      break
if limit > 0:
  print >> sys.stderr, "examined %d topologies in %.1f seconds," \
        % (nCandidatesTried, time() - startTime),
  
if progress or limit > 0:
  print >>  sys.stderr, "done." 

if options.score:
  print '[&W %g]' % bestScore,

if bestTree:
  print toNewick(bestTree)
