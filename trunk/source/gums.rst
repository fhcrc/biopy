===========================================
Gene trees Under Migration Simulator (GUMS)
===========================================

GUMS simulates a gene tree under a multispecies coalescent + migration
model. GUMS takes as input the species tree and migration parameters. The input
can be completely specified in the command line, but species tree(s) can be read
from a NEXUS file if desired.

The species tree is specified in a `NEWICK
<http://en.wikipedia.org/wiki/Newick_format/>`_ format, augmented with meta data
in a similar format to the one used in BEAST, which was inspired by `NHX
<http://phylosoft.org/NHX//>`_. The effective population size(s) have the same
format as generated by \*BEAST (:ref:`MetapopSize`), and migration rates can be
explicit in a similar way or generated stochastically.

If you don't have a specific species tree(s) in mind, biopy can generate trees
from a Birth/Death process (:ref:`sameSpTrees`).

Most options are straightforward and their usage should be obvious from the help
text (**gums -h**) and the examples below. However, setting the migration rates
in a species tree context requires more care. In our model, rates may change and
are given as a function over time, just like population sizes. There are two
rates associated with each divergence of the ancestral species A into
:math:`A_1` and :math:`A_2` - one for :math:`A_1 \rightarrow A_2` and one for
:math:`A_2 \rightarrow A_1`. In our model, those rates are in effect even if
:math:`A_1` or :math:`A_2` split further when migration is in effect. For that
reason, the domain of each rate function is from 0 (time of tips) to time of
divergence (internal node height), unlike population size whose domain is only
the branch.

The easiest way to set the rates is to use the ``-s`` (``--scenario``)
option. Currently there are three scenarios, constant, balanced and gradual. In
the constant scenario the rates are constant (i.e. have a fixed value from the
time of divergence to the tips), and are drawn independently from a user defined
distribution. The balanced scenario is similar, but the rates :math:`A_1
\rightarrow A_2` and :math:`A_2 \rightarrow A_1` are always equal. The gradual
scenario uses two parameters, M and S. The rate function is linear, starting at
M at the time of divergence and drops to 0 at S. Both M and S are drawn from a
user provided distributions. Also, migration into :math:`A_1` and :math:`A_2`
from other species is not allowed after migration stops between :math:`A_1` and
:math:`A_2`. The usage section provides some examples, and :ref:`randDists`
lists all available random distributions.

Alternatively, rates can be set explicitly in the tree. A rate function is
specified using the ``imrv`` and ``imrt`` meta attributes, providing the values
at time points for a piecewise linear function, exactly in same way as ``dmv``
and ``dmt`` (:ref:`MetapopSize`). The tricky part is that the data in the
internal node specifies the rate function for the parent node: this seems the
easiest way to work around the fact that each node requires rates for the left
and right sub-trees, but the order of sub-trees in the NEWICK format is
arbitrary. If you are still confused, looking at the examples below and at
logged species trees (``--log``) generated under the gradual scenario may help.


Usage:
------

::

 # Specify tree and migration rates in the command line. The (constant)
 # population size is given by dmv: 2 for 'a', 1 for 'b' and 1 for the
 # ancestor. Migration rate (M) is constant as well, given by 'imrv' (.4 for a
 # and .6 for b).
 # By default gums prints one gene tree to standard output. The total number of
 # migration events is reported in 'nim'.


| $ **gums  "(a[&imrv=0.4,dmv=2]:1,b[&imrv=0.6,dmv=1]:1)[&dmv=1]"**
| ((b_tip1:0.645476769587,a_tip0:0.645476769587):0.95831702107,(b_tip0:1.34933738445,a_tip1:1.34933738445):0.254456406207)[&nim 2]

::

 # Generate two trees (-n 2)

| $ **gums -n 2 "(a[&imrv=0.4,dmv=2]:1,b[&imrv=0.6,dmv=1]:1)[&dmv=1]"**
| ((a_tip1:0.479886426509,b_tip1:0.479886426509):2.40342028268,(b_tip0:0.393951094328,a_tip0:0.393951094328):2.48935561487)[&nim 2]
| (((b_tip0:0.0945651926813,b_tip1:0.0945651926813):0.918685788982,a_tip0:1.01325098166):0.613837824988,a_tip1:1.62708880665)[&nim 4]

::

 # Output trees to 'trees.nex' in NEXUS format
  
| **$ gums -o trees.nex "(a[&imrv=0.4,dmv=2]:1,b[&imrv=0.6,dmv=1]:1)[&dmv=1]"**
| **$ cat trees.nex**

::

  [Generated by genetree_in_sptree_mig_sim.py, version 0.1.6]
  [/usr/local/bin/gums -o trees.nex (a[&imrv=0.4,dmv=2]:1,b[&imrv=0.6,dmv=1]:1)[&dmv=1]]
  #NEXUS
  begin trees;
  tree tree_0 = [&R] (((b_tip1:0.252172456527,a_tip1:0.252172456527):0.113487587236,a_tip0:0.365660043763):2.12869603649,b_tip0:2.49435608026)[&nim 4] ;
  end;

::

  # Explicitly specify lineages (the labels attribute)
  
| **$ gums "(a[&imrv=0.4,dmv=2,labels=a1 a2 a3]:1,b[&imrv=0.6,dmv=1,labels=b1 b2]:1)[&dmv=1]"**
| (((a3:0.378861178516,a1:0.378861178516):0.0121979519199,b1:0.391059130436):1.97747893368,(b2:0.606737574127,a2:0.606737574127):1.76180048999)[&nim 4]

::

  # Simulate with 3 lineages per species.

| **$ gums -t 3 "(a[&imrv=0.4,dmv=2]:1,b[&imrv=0.6,dmv=1]:1)[&dmv=1]"**
| (((a_tip0:0.260681648931,a_tip2:0.260681648931):1.08306884015,(b_tip0:0.671588798321,(b_tip1:0.291571820222,b_tip2:0.291571820222):0.380016978099):0.672161690764):0.285979539237,a_tip1:1.62973002832)[&nim 6]

::

  # Use a constant M for all branches
  
| **$ gums --scenario constant .4 "(a[&dmv=2]:1,b[&dmv=1]:1)[&dmv=1]"**
| ((a_tip1:1.37587574756,(b_tip0:0.114472140834,b_tip1:0.114472140834):1.26140360672):0.670541106981,a_tip0:2.04641685454)[&nim 1]

::

  # M for every branch is assigned independently, sampled from a uniform
  # distribution on [0.3,0.5]
  
| **$ gums --scenario constant u,.3,.5 "(a[&dmv=2]:1,b[&dmv=1]:1)[&dmv=1]"**
| (((b_tip0:0.745703759372,a_tip0:0.745703759372):0.346829780156,b_tip1:1.09253353953):4.12033590372,a_tip1:5.21286944325)[&nim 2]

::

  # M for every divergence is assigned independently, migration rate of X -> Y is equal to Y ->
  # X. The -l (--log) option logs the generated species trees

| **$ gums -l sptrees.nex --scenario balanced u,.3,.5 "(a[&dmv=2]:1,b[&dmv=1]:1)[&dmv=1]"**
| ((a_tip0:0.544745625794,a_tip1:0.544745625794):1.35928052487,(b_tip1:0.258689734603,b_tip0:0.258689734603):1.64533641606)[&nim 1]
| **$ cat sptrees.nex**

::

  #NEXUS
  begin trees;
  tree tree_0 = [&R] (a[&imrv=0.468464300359,dmv=2.000000]:1.0,b[&imrv=0.468464300359,dmv=1.000000]:1.0)[&dmv=1.000000] ;
  end;

::

  # Non-constant Population sizes. 'a' population size varies linearly between 2
  # (at time 0, tip of branch) to 1/2 at the end of the branch (1 time unit ago)
  
| **$ gums -l sptrees.nex --scenario constant .4 "(a[&dmv={2,0.5}]:1,b[&dmv=1]:1)[&dmv=1]"**
| ((b_tip1:0.510950861838,(a_tip1:0.0824282355471,b_tip0:0.0824282355471):0.428522626291):1.17963320687,a_tip0:1.69058406871)[&nim 1]

::

  Gradual scenario.
  
| **$ gums --scenario gradual u,.3,.5 l,.3,.2 --log trees.nex "((a[&dmv=2]:1,b[&dmv=1]:1)[&dmv=1]:1,c[&dmv=1]:3)[&dmv=1]"**
| ((c_tip0:0.530848069964,c_tip1:0.530848069964):4.58955020846,((b_tip1:0.0991069047618,b_tip0:0.0991069047618):1.97184729447,(a_tip0:0.391830914289,a_tip1:0.391830914289):1.67912328494):3.04944407919)[&nim 1]

This is how the generated rates looks like inside the tree

::

  ((a[&imrt={0.600357,1.000000},imrv={0.000000,0.000000,0.354169},dmv=2.0]:1.0,
    b[&imrt={0.600357,1.000000},imrv={0.000000,0.000000,0.354169},dmv=1.0]:1.0)
                 [&imrt={2.828391,3.000000},imrv={0.000000,0.000000,0.316630},dmv=1.0]:1.0,
   c[&imrt={2.828391,3.000000},imrv={0.000000,0.000000,0.316630},dmv=1.0]:3.0)[&dmv=1.0]


The rate between a and b starts at 0.354169 and goes to zero over 0.399643 (1
-0.600357) time units. In a similar way, rate between c and the ancestor of a,b
goes from 0.316630 to zero in 0.171609.

