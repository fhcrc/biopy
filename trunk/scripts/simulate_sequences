#! /usr/bin/env python
## This file is part of biopy.
## Copyright (C) 2010 Joseph Heled
## Author: Joseph Heled <jheled@gmail.com>
## See the files gpl.txt and lgpl.txt for copying conditions.

from __future__ import division

import argparse, sys, os.path

parser = argparse.ArgumentParser(description= """%prog [OPTIONS] trees-file-or-tree

    Simulation sequences for tips of a gene tree using a substitution model.""")

parser.add_argument("-n", "--seqlen", metavar="N", type = int,
                    help="""Alignment length. (default %(default)d))""", default = 400) 

parser.add_argument("-m", "--model",
                    help="Substitution model. Comma separated list - model name"
                    " and model parameters. (1) JC,mu  (2) HKY,mu,kappa,freqs (3)"
                    " GTR,mu,rates,freqs" 
                    " (default %(default)s)", default = "JC,1") 

parser.add_argument("-c", "--clock", metavar="DIST",
                    help = "Molecular clock. The mutation rate of each branch is"
                    " multipled of a random value drawn from DIST. A number "
                    " by itself specifies a constant. Otherwise, a comma separated list where the"
                    " first character specifies the distribution. See the documentation for supported"
                    " distributions.", default = None)

parser.add_argument("-a", "--annotate", metavar="FILE",
                    help="Output trees with sequences embedded in tips annotation. By default,"  
                    " generate one NEXUS alignment file per tree.",
                    default = None)

parser.add_argument("-o", "--nexus", dest="nexfile", metavar="FILE",
                    help="Name of annotated trees file or base of alignment file.", default = None)


parser.add_argument('trees', metavar='FILE', help="Trees file (or explicit tree)")

from biopy import INexus, submodels, __version__
from biopy.treeutils import toNewick, TreeLogger
from biopy.randomDistributions import parseDistribution

options = parser.parse_args()

## if len(args) == 0 :
##   parser.print_help(sys.stderr)
##   sys.exit(1)

#if options.annotate and not options.nexfile :
#  print >> sys.stderr, "Please specify a file name with -a."
#  parser.print_help(sys.stderr)
#  sys.exit(1)

targ = options.trees
if os.path.isfile(targ) :
  trees = list(INexus.INexus().read(file(targ)))
else :
  if targ[0] != '(' :
    print >> sys.stderr, "Command line argument is not a file or a newick tree"
    sys.exit(1)
    
  try :
    trees = [INexus.Tree(targ)]
  except Exception,e:
    print >> sys.stderr, "*** Error: failed to parse tree: ",e.message,"[",targ,"]"
    sys.exit(1)

seqLen = options.seqlen
if seqLen <= 0 :
  parser.print_help(sys.stderr)
  sys.exit(1)

try :
  clockDist = parseDistribution(options.clock) if options.clock else None
except RuntimeError, e:
  print >> sys.stderr, "*** Error:", e.message
  sys.exit(1)

def parseFreqs(freqs) :
  pi = [0]*4
  qMat = [1]*7
  
  while len(freqs) >= 2 :
    code,f = freqs[:2]

    try:
      f = float(f)
    except :
      raise ValueError(f)
    
    freqs = freqs[2:]
    
    if len(code) == 1 :
      c = submodels.SubstitutionModel.NUCS.index(code)
      if not 0 <= c < 4 :
        raise RuntimeError("Can't parse nucleotide frequency" + ",".join(freqs))
      if not 0 < f < 1 :
        raise RuntimeError("Illegal nucleotide frequency: " + f)
      pi[c] = f
    elif len(code) == 2 :
      c1,c2 = sorted([submodels.SubstitutionModel.NUCS.index(c) for c in code])
      if c1 == c2 :
        raise RuntimeError("Illegal nucleotide specification: ", code)
      if f <= 0 :
        raise RuntimeError("Illegal rate: " + f)
      qMat[2*c1 + c2-1] = f
      
  notAssigned = sum([x == 0 for x in pi])
  if notAssigned > 0 :
    if sum(pi) >= 1 :
      raise("Illegal nucleotide stationary frequencies: sum to more than 1")
    p = (1 - sum(pi))/notAssigned
    for k in range(4) :
      if pi[k] == 0 :
        pi[k] = p
  else :
    if sum(pi) != 1 :
      print >> sys.stderr, "Nucleotide frequencies do not sum to 1 - normalizing..."
      pi = [x/sum(pi) for x in pi]

  return pi,[x/qMat[-1] for x in qMat][:-1]

try :
  model = options.model.split(',')
  modelName = model[0].upper()
  if modelName == 'JC' :
    mu = float(model[1]) if model[1] else 1
    smodel = submodels.JCSubstitutionModel(mu)
  elif modelName == 'HKY':
    mu = float(model[1]) if model[1] else 1
    kappa = float(model[2]) if model[2] else 1
    freqs = model[3:]
    pi = parseFreqs(freqs)[0]
    smodel = submodels.HKYSubstitutionModel(mu = mu, kappa = kappa, pi = pi)
  elif modelName == 'GTR':
    mu = float(model[1]) if model[1] else 1
    freqs = model[2:]
    pi,qMat = parseFreqs(freqs)
    smodel = submodels.StationaryGTR(mu = mu, m = qMat, pi = pi)
except RuntimeError as r:
  print >> sys.stderr, "error in parsing model." + r.message
  sys.exit(1)

tlog = None
if options.annotate :
  tlog = TreeLogger(options.annotate, argv = sys.argv, version = __version__)

from biopy.INexus import exportMatrix
  
for count,tree in enumerate(trees):
  smodel.populateTreeSeqBySimulation(tree, seqLen, clockDist)

  for n in tree.get_terminals() :
    data = tree.node(n).data
    if not hasattr(data, "attributes") :
      data.attributes = dict()
    data.attributes['seq'] = smodel.toNucCode(data.seq)

  if tlog :
    treeTxt = toNewick(tree, attributes = 'attributes')
    tlog.outTree(treeTxt, name = tree.name)

  if options.nexfile or not tlog:
    base = tree.name or options.nexfile or "alignment"
    if len(trees) > 1 and not tree.name :
      fname = "%s%d" % (base, count)
    else :
      fname = base
      
    if not fname.endswith(".nex") :
      fname = fname + ".nex"
      
    d = dict()
    for n in tree.get_terminals() :
      data = tree.node(n).data
      d[data.taxon] = data.attributes['seq']

    f = file(fname, "w")
    print >> f, "[Generated by %s%s]" % \
          (os.path.basename(sys.argv[0]),
           (", version " + __version__) if __version__ is not None else "")
    print >> f, "[%s]" % " ".join(sys.argv)

    exportMatrix(f, d)
    f.close()
    
if tlog:
  tlog.close()

